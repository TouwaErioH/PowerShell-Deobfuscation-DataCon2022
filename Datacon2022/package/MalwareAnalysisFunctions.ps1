<#
Function name: GetObfuscationType
Description: Determines the obfuscation type of the obfuscated script received as input 
Function calls: IsCompressed, IsBase64, IsStringBased, IsEncoded.
Input: $ObfuscatedScript 
Output: (a string representing the obfuscation type)
#>

function GetObfuscationType() {
	param(
        [Parameter(
			Mandatory = $True)]
        [string]$ObfuscatedScript
    )

  if( IsCompressed $ObfuscatedScript ) {
      return "Compressed"
   }
     if( IsEncoded $ObfuscatedScript ) { 
      return "Encoded"  
  }
   
   if( IsStringBased $ObfuscatedScript ) {    
      return "String-Based"
  }
    
  if( IsBase64 $ObfuscatedScript ) {   
      return "Base64"   
  }
  
 
  
  
        
 
  else {  
      return "Unknown" 
  }

   
}

<#
Function name: IsCompressed
Description: Returns true if the obfuscation type is compressed 
Function calls: -
Input: $ObfuscatedScript
Output: $true/$false  
#>
function IsCompressed() {
	param(
        [Parameter(
			Mandatory = $True)]
        [string ]$ObfuscatedScript
    )
	
#to lower conversion 
$lowerstring = $ObfuscatedScript.toLower() 




$DeflatePattern = [regex] "io\.compression\.deflatestream"
$GzipPattern = [regex] "io\.compression\.gzipstream"

$DeflateMatches = $DeflatePattern.matches($lowerstring)
$GzipMatches = $GzipPattern.matches($lowerstring)


if ($DeflateMatches.Count -gt 0){
     return $true 
     }
	 
if ($GzipMatches.Count -gt 0){
     return $true 
     } 


return $false 


}

<#
Function name: IsEncoded
Description: Returns true if the obfuscation type is encoded
Function calls: -
Input: $ObfuscatedScript
Output: $true/$false   
#>
function IsEncoded() {
	param(
        [Parameter(
			Mandatory = $True)]
        [string]$ObfuscatedScript
    )

$lowerstring = $ObfuscatedScript.toLower() 



#checking bxor
$pattern = [regex] "\-bxor"
$matches = $pattern.Matches($lowerstring)
   if ($matches.Count -gt 0){
     return $true 
     } 

#checking secure string
$pattern = [regex] "securestring"
$matches = $pattern.Matches($lowerstring)
   if ($matches.Count -gt 0){
     return $true 
     }
#checking hex\oct\bin 
$pattern = [regex]  "\[convert\]\:\:toint16"
$matches = $pattern.Matches($lowerstring)
   if ($matches.Count -gt 0){
     return $true 
     }


#remove spacelines 
$pattern = [regex]  " "
$matches = $pattern.Matches($lowerstring)

foreach  ($match in $matches) {

$ScriptNoSpacelines = $lowerstring.Replace( $match, '') 
}


#checking dec 
$pattern = [regex]  "\[int\]$_"
$matches = $pattern.Matches($ScriptNoSpacelines)
   if ($matches.Count -gt 0){
     return $true 
     }


return $false


}


<#
Function name: IsStringBased
Description: Returns true if the obfuscation type is string-based
Function calls: -
Input: $ObfuscatedScript
Output: $true/$false
#>

function IsStringBased() {
	param(
        [Parameter(
			Mandatory = $True)]
        [string]$ObfuscatedScript
    )


$regex= @"
(\(){0,}(\s){0,}[\"\'](\s){0,}(\{\d+\}){1,}(\s){0,}[\"\'](\s){0,}\-(\s){0,}[fF](.){0,}(\s){0,}(\)){0,}
"@

       $pattern = [regex] $regex
       $matches = $pattern.Matches($ObfuscatedScript) 

if ($matches.Count -gt 0){
     return $true
}



 $pattern = [regex] "(\{\d\}\'\s*-f)|(\'(.*?)\'\s*\+\s*\'(.*?)\')"
 $matches = $pattern.Matches($ObfuscatedScript) 

    if ($matches.Count -gt 0){
     return $true 
     }
     else {
      $lowerstring = $ObfuscatedScript.toLower() 
    
        
    $pattern = [regex] "\[char\]\d" 
    $matches = $pattern.Matches($lowerstring) 


     if ($matches.Count -gt 0){
     return $true 
     }
     
     
     
     
    $pattern = [regex] "\'righttoleft\'" 
    $matches = $pattern.Matches($lowerstring) 


     if ($matches.Count -gt 0){
     return $true 
     }
     
     
     
     
     return $false
     }
}


<#
Function name: BitmapFetch
Description: Returns true if script contains bitmap image fetch instrucion
Function calls: -
Input: $ObfuscatedScript
Output: $true/$false
#>

function BitmapFetch() {
	param(
        [Parameter(
			Mandatory = $True)]
        [string ]$ObfuscatedScript
    )
	
#to lower conversion 
$lowerstring = $ObfuscatedScript.toLower() 

$BitmapPattern = [regex] "system\.drawing\.bitmap"

$Matches = $BitmapPattern.matches($lowerstring)


if ($Matches.Count -gt 0){
     return $true 
     }
	 
return $false 


}



<#
Function name: ExtractUrls
Description: Receives a script as input and returns an array containing all urls detected  
Function calls: -
Input: $Script
Output: $Urls  
#>

function ExtractUrls() {
	param(
        [Parameter(
			Mandatory = $True)]
        [string]$Script
    )
	
	
	
	
	$Urls = @()
	$Url = ""
	
	 
	
	$Pattern = [regex]  "(http[s]?|[s]?ftp[s]?)(:\/\/)(.*?)(\""|\'|\}|\@|\,|\s|\*|\?)"
	
	$Matches = $Pattern.matches($Script)
	
	Foreach($Group in $Matches.Groups) {
		if($Group.Name -eq 0) {
			$Url = $Group.Value
			$Url = $Url.SubString(0, $Url.Length - 1)
			$Urls += $Url
		}
	}
		
	
	return $Urls
}

<#
Function name: UrlHttpResponseCheck
Description: Receives a url as input and returns the associated http response status code  
Function calls: ConvertHexStringToByteArray UpdateReport
Input: $Url
Output: $UrlInfo 
#>

function UrlHttpResponseCheck() {
	param([Parameter(Mandatory = $True)] [string]$Url
    )
	
	$HttpRequest = [System.Net.WebRequest]::Create($Url)
	
	
	try {
		$HttpResponse = $HttpRequest.GetResponse()
	}
	catch [Net.WebException] {
     $HttpResponse = $_.Exception.Response
     $HttpStatus = [int]$HttpResponse.StatusCode       
		
	}
	$HttpStatus = [int]$HttpResponse.StatusCode
	
	
switch ( $HttpStatus ) {
		
    101 {$Info ="[101: Switching Protocols] - "; Break}
    200 {$Info ="[200: Url is Active] - " ; Break }
    201 {$Info ="[201: Created] - " ; Break }
    202 {$Info ="[202: Accepted] - " ; Break }
	204 {$Info ="[204: No Content] - "; Break}
    301 {$Info ="[301: Moved Permanently] - " ; Break }
    302 {$Info ="[302: Found] - " ; Break }
    304 {$Info ="[304: Not Modified] - " ; Break }
	400 {$Info ="[400: Bad Request] - "; Break}
    401 {$Info ="[401: Unauthorized] - " ; Break }
    403 {$Info ="[403: Forbidden] - " ; Break }
    404 {$Info ="[404: Not Found] - " ; Break }
    405 {$Info ="[405: Method not Allowed] - "; Break}
    406 {$Info ="[406: Not Acceptable] - " ; Break }
    407 {$Info ="[407: Proxy Authentication Required] - " ; Break }
    415 {$Info ="[415: Unsupported Media Type] - " ; Break }
	422 {$Info ="[422: Unprocessable Entity] - "; Break}
    500 {$Info ="[500: Internal Server Error] - " ; Break }
    503 {$Info ="[503: Service Unavaiable] - " ; Break }
	504 {$Info ="[504: Gateway Timeout] - " ; Break }
    default {$Info = "[ "+$HttpStatus+" ] Cannot connect to: " ; Break }

}

$UrlInfo = $Info + " "  + $Url  	
return  $UrlInfo   
	
}

<#
Function name: ExtractShellcode
Description: Checks and exstract shellcode from input script   
Function calls: ConvertHexStringToByteArray, GetAssemblyInstructions , BxorShellcode
Input:  $Script , $BxorKey
Output: $data   
#>

function ExtractShellcode()  {
        param(
            [Parameter( 
                Mandatory=$True, 
                Valuefrompipeline = $True)]
            [string]$Script ,
			
			[Parameter( 
                Mandatory=$False, 
                Valuefrompipeline = $True)]
            [int]$BxorKey
		)
      
      
$data = ""

#hex format shellcode check  

$pattern = [regex]  "(0x[0-9a-z]\,){1,1}"
$matches = $pattern.matches($Script)

foreach ($match in $matches){
  $byte = $match.value.replace('0x', '' )
  $Script = $Script.replace(  $match.value ,"0x0"+$byte   )
}

$lowerstring = ($Script.toLower()) |Out-String
$lowerstring = $lowerstring.replace('0x','').replace(',',' ')

$pattern =  [regex] "\=[a-f0-9\s]{8,}(\;){0,1}"
$matches = $pattern.matches($lowerstring)
if ($matches.count -gt 0) {
 $shellcode = $matches[0].value
 $shellcode= $shellcode.replace('=','').replace(';','')
 $HexString = $shellcode.replace(' ', '')
 
 [byte[]] $bytes = ConvertHexStringToByteArray $HexString 
 
 
 if ($BxorKey) { 
       $bytes  =  BxorShellcode $bytes $BxorKey 
	   $HexString = $bytes | Foreach-Object {[System.Convert]::ToString($_,16)}
	   $i=0
	   foreach ($h in $HexString) { 
	     if ($h.length -lt 2) {    
		    $HexString[$i] = "0"+$h
		 }   
		$i++;
		}
	   $HexString = [String]::Join('', $HexString)
	   
	   }
 
 
 $assembly = Format-Hex -InputObject $bytes
  

 $AssemblyInstructions =  (GetAssemblyInstructions -Architecture X86 -Mode Mode16 -Code $bytes -Offset 0x1000) | Out-String 
 
 
 

 $data = "Script attempts to inject shellcode into memory: " + "`r`n`r`n" + $assembly
 $data += "`r`n`r`n" +"Assembly instructions:"+$AssemblyInstructions +"`r`n`r`n"
 
if (!(Test-Path scdbg.exe)){
 $data += "`r`n`r`n" +"PowerDecode analysis ends here, please analyze this code on a debugger to get more information:"+ "`r`n`r`n"
 $data += "`r`n"+"Input for SCDBG (http://sandsprite.com/blogs/index.php?uid=7&pid=152):"+"`r`n"+$HexString+ "`r`n"
 $data += $heading = "`r`n" +"########## You can place the scdbg.exe file on the PowerDecode folder "+ "`r`n"
 }

else {
 $HexString  | Out-File -Encoding ASCII sh.txt
 $scdbg = (.\scdbg -f sh.txt -nc) |Out-String

 $data += "`r`n"+"Following string has been analyzed by SCDBG (http://sandsprite.com/blogs/index.php?uid=7&pid=152):"+"`r`n"+$HexString+ "`r`n"
 $data += $heading = "`r`n`r`n" +"##########"+ "`r`n"
 $data += $heading = "`r`n`r`n" +"SCDBG Execution report:"+ "`r`n"
 $data += "`r`n"+$scdbg+ "`r`n"
 Remove-Item sh.txt
 }
 
  
}


#Base64 shellcode check
$regex =@"
\[[Bb][Yy][Tt][Ee]\[\]\][\$](.*?)\= \[System\.Convert\]\:\:FromBase64String\(["']{1,1}([A-Za-z0-9\+\/]{5,})[\=]{0,2}
"@

$pattern = [regex] $regex
$matches = $pattern.matches($Script)


if ($matches.count -gt 0) {

$shellcode = $matches[0].value

$regex =@"
\[[Bb][Yy][Tt][Ee]\[\]\][\$](.*?)\= \[System\.Convert\]\:\:FromBase64String\(["']{1,1}
"@

$pattern = [regex] $regex
$matches = $pattern.matches($shellcode)

$junkdata = $matches[0].value
$shellcode= $shellcode.replace($junkdata ,"")

[Byte[]] $bytes = [System.Convert]::FromBase64String($shellcode)
$HexString = ($bytes|ForEach-Object ToString X2) -join ' '
$HexString = $HexString.replace(" ","")

if ($BxorKey) { 
       $bytes  =  BxorShellcode $bytes $BxorKey 
	   $HexString = $bytes | Foreach-Object {[System.Convert]::ToString($_,16)}
	   $i=0
	   foreach ($h in $HexString) { 
	     if ($h.length -lt 2) {    
		    $HexString[$i] = "0"+$h
		 }   
		$i++;
		}
	   $HexString = [String]::Join('', $HexString)
	   
	   }


$assembly = Format-Hex -InputObject $bytes

$AssemblyInstructions =  (GetAssemblyInstructions -Architecture X86 -Mode Mode16 -Code $bytes -Offset 0x1000) | Out-String 

$data += "Shellcode was base64 encoded " + "`r`n`r`n" + $assembly

$data = "Script contains base64 encoded shellcode: " + "`r`n`r`n" + $assembly
$data += "`r`n`r`n" +"Assembly instructions:"+$AssemblyInstructions +"`r`n`r`n"

if (!(Test-Path scdbg.exe)){
 $data += "`r`n`r`n" +"PowerDecode analysis ends here, please analyze this code on a debugger to get more information:"+ "`r`n`r`n"
 $data += "`r`n"+"Input for SCDBG (http://sandsprite.com/blogs/index.php?uid=7&pid=152):"+"`r`n"+$HexString+ "`r`n"
 $data += $heading = "`r`n" +"########## You can place the scdbg.exe file on the PowerDecode folder "+ "`r`n"
}

else {
$HexString  | Out-File -Encoding ASCII sh.txt
$scdbg = (.\scdbg -f sh.txt -nc) |Out-String

$data += "`r`n"+"Following string has been analyzed by SCDBG (http://sandsprite.com/blogs/index.php?uid=7&pid=152):"+"`r`n"+$HexString+ "`r`n"
$data += $heading = "`r`n`r`n" +"##########"+ "`r`n"
$data += $heading = "`r`n`r`n" +"SCDBG Execution report:"+ "`r`n"
$data += "`r`n"+$scdbg+ "`r`n"

Remove-Item sh.txt
}

}

return  $data 


}


<#
Function name: BxorShellcode
Description: Takes an array of bytes as input and performs bxor with a key value. Result is returned 
Function calls: -
Input: $VarCode , $key
Output: $VarCode
#>

function BxorShellcode()  {
        param(
            [Parameter( 
                Mandatory=$True, 
                Valuefrompipeline = $True)]
            [Byte[]]$VarCode ,
			
			 [Parameter( 
                Mandatory=$True, 
                Valuefrompipeline = $True)]
            [int]$key
        
		)
      

for ($i = 0; $i -lt $VarCode.Count; $i++) {        
 $VarCode[$i] = $VarCode[$i]  -bxor $key
 }
 


return $VarCode
}


<#
Function name: ConvertHexStringToByteArray
Description: Takes an array of hexadecimals as input and returns an array containing those values converted into bytes
Function calls: -
Input: $String
Output: $bytes
#>

function ConvertHexStringToByteArray
{

[CmdletBinding()]
Param ( [Parameter(Mandatory = $True, ValueFromPipeline = $True)] [String] $String )


if ($String.Length -eq 0) { 
return 
}
 
if ($String.Length -eq 1) { 
[byte[]] $bytes = ([System.Convert]::ToByte($String,16)) 
return $bytes 
}

if (($String.Length % 2 -eq 0) -and ($String.IndexOf(":") -eq -1)) { 
[byte[]] $bytes = $String -split '([a-f0-9]{2})' | foreach-object { if ($_) {[System.Convert]::ToByte($_,16)}} 
return $bytes 
}
else{
      if ($String.IndexOf(":") -ne -1){ 
      [byte[]] $bytes = $String -split ':+' | foreach-object {[System.Convert]::ToByte($_,16)} 
      return $bytes 
	  }
}

}

<#
Function name: GetAssemblyInstructions
Description: Takes an array of bytes as input and returns its assembly instructions
Function calls: -
Input: $bytes
Output: -
#>


function GetAssemblyInstructions () {

    [OutputType([Capstone.Instruction])]
    [CmdletBinding(DefaultParameterSetName = 'Disassemble')]
    Param (
        [Parameter(Mandatory, ParameterSetName = 'Disassemble')]
        [Capstone.Architecture]
        $Architecture,

        [Parameter(Mandatory, ParameterSetName = 'Disassemble')]
        [Capstone.Mode]
        $Mode,

        [Parameter(Mandatory, ParameterSetName = 'Disassemble')]
        [ValidateNotNullOrEmpty()]
        [Byte[]]
        $Code,

        [Parameter( ParameterSetName = 'Disassemble' )]
        [UInt64]
        $Offset = 0,

        [Parameter( ParameterSetName = 'Disassemble' )]
        [UInt32]
        $Count = 0,

        [Parameter( ParameterSetName = 'Disassemble' )]
        [ValidateSet('Intel', 'ATT')]
        [String]
        $Syntax,

        [Parameter( ParameterSetName = 'Disassemble' )]
        [Switch]
        $DetailOn,

        [Parameter( ParameterSetName = 'Version' )]
        [Switch]
        $Version
    )

    if ($PsCmdlet.ParameterSetName -eq 'Version')
    {
        $Disassembly = New-Object Capstone.Capstone([Capstone.Architecture]::X86, [Capstone.Mode]::Mode16)
        $Disassembly.Version

        return
    }

    $Disassembly = New-Object Capstone.Capstone($Architecture, $Mode)

    if ($Disassembly.Version -ne [Capstone.Capstone]::BindingVersion)
    {
        Write-Error "capstone.dll version ($([Capstone.Capstone]::BindingVersion.ToString())) should be the same as libcapstone.dll version. Otherwise, undefined behavior is likely."
    }

    if ($Syntax)
    {
        switch ($Syntax)
        {
            'Intel' { $SyntaxMode = [Capstone.OptionValue]::SyntaxIntel }
            'ATT'   { $SyntaxMode = [Capstone.OptionValue]::SyntaxATT }
        }

        $Disassembly.SetSyntax($SyntaxMode)
    }

    if ($DetailOn)
    {
        $Disassembly.SetDetail($True)
    }

   
	$Disassembly.Disassemble($Code, $Offset, $Count)
    
	return

}


<#
Function name: GetVariablesContent
Description: Takes a script as input and returns a list containing the variables declared by the same (name-value) 
Function calls: EncodeBase64
Input: $Script
Output: $Variables
#>


function GetVariablesContent()  {
        param(
            [Parameter( 
                Mandatory=$True, 
                Valuefrompipeline = $True)]
            [string]$Script 
        )

$Declarations = ""
foreach ($row in $Script.split(';')) {
 if (($row -match "$") -and  ($row -match '=')   ) { 
   $Declarations += $row + " ;"

 }
}



$GetUDVariables = get-content package\GetUDvariables.txt
$Arguments = $Declarations+"`r`n"+$GetUDvariables

$B64Arguments = EncodeBase64 $Arguments
$B64Arguments = "powershell -encodedcommand " + $B64Arguments


$TempFile = [System.IO.Path]::GetTempPath() + [GUID]::NewGuid().ToString()+"GVC"+ ".ps1"; 
            
$B64Arguments | Out-File $TempFile


$ProcessInfo = New-Object System.Diagnostics.ProcessStartInfo
$ProcessInfo.FileName = "powershell"
$ProcessInfo.CreateNoWindow = $true
$ProcessInfo.RedirectStandardError = $false
$ProcessInfo.RedirectStandardOutput = $true
$ProcessInfo.UseShellExecute = $false
$ProcessInfo.Arguments = "-File $($TempFile)"
$Process = New-Object System.Diagnostics.Process
$Process.StartInfo = $ProcessInfo
$Process.Start() | Out-Null
$Variables = $Process.StandardOutput.ReadToEnd()
Stop-Process $Process
Remove-Item $TempFile

if ($Variables -match "ParserError") {
	return ""
}

return $Variables

}

<#
Function name: UpdateReport
Description: Receives a data string as input and stores it in a report file    
Function calls: -
Input: $data
Output: -
#>


function UpdateReport( ) {
	param(
        [Parameter(
			Mandatory = $True)]
        [string]$data 
    )


    $ReportFileName = "PowerDecode_2020_Malware_Analysis_Temp_Report"
    $ReportOutFile =  [System.IO.Path]::GetTempPath() + $ReportFileName +".txt" 
    
    
    $Report = Get-Content $ReportOutFile  
    $Report += $data 
    $Report | Out-File $ReportOutFile 


return 

}